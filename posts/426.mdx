---
title: '[42Seoul] mini_talk'
date: '2024-01-08'
tags: ['42Seoul']
series: '42Seoul'
---

Push_swap을 구현하고 다음 과제로 Minitalk을 하기로 결정했다.

서브젝트를 읽어보니 재밌어 보였고 쉽게 해낼 수 있을 것 같았다.

Makefile을 통해 두 개의 파일을 생성해야한다.
`server` `client`

`server`가 먼저 실행되며 PID가 출력된 후 `client`의 `siganl`을 대기한다.

`client`는 `./clinet SERVER_PID SEND_STRING`과 같이 argc가 3으로 고정되게 실행하며 문자열을 전송한다.

이 때 사용가능한 siganl은 USR1, USR2 두 개로 제한된다.

서버는 다수의 client에게 **연속적**으로 문자열을 받을 수 있어야하며 최대한 빠르게 문자를 출력해준다.

#### 구현

-   **SERVER**

1. server에서 getpid() 함수를 통해 pid를 받아와 libft에서 구현했던 ft_putnum_fd와 같은 함수로 출력 해준다. getpid는 실패하지 않기 때문에 예외에 대해 생각해주지 않아도 된다. (프로세스가 실행중이기 때문에)
2. 이후 무한 loop 내에서 pause() 함수를 통해 시그널을 대기한다.
3. signal이 들어왔을 때 처리할 시그널 핸들러를 만들어 sigaction 혹은 signal 함수를 통해 USR1, USR2 시그널이 들어올 경우 시그널 핸들러 함수를 호출할 수 있도록 등록해둔다.
4. 시그널 핸들러는 정적으로 1byte 완성 시 출력할 `char` 변수와 들어온 BIT가 8개인지 확인할 `int` 변수를 선언한다.
5. signo를 통해 USR1과 USR2를 본인이 정해준 기준대로 비트 1과 0으로 구분하고 받은 시그널의 수를 증가시키고 `char` 변수에 비트를 밀어 넣는다. 8개의 시그널을 받을 시 글자를 출력하고 시그널 수를 0으로 초기화하며 다음 글자를 기다린다.

이 때, `char` 변수에 한 글자만큼 넣기 위해선 `client` 프로그램에선 글자의 최상위 비트부터 한 비트씩 `server`에 시그널을 보내고, `server`는 최상위 비트부터 `char`에 비트를 받는다.

-   **CLIENT**

1. argv[3] 부분을 첫 글자부터 bit 단위로 비트 연산을 통해 나눈 후에 `kill()` 명령어를 통해 server에 시그널을 보낸다.
2. 본인의 기준으로 1과 0을 각각 usr1, usr2로 정하고 보내면 된다. 한 bit를 보내고 usleep을 통해 잠시 대기해줘야 시그널 펜딩 배열에서 signal이 대기하는 과정에서 시그널이 유실되지 않는다.

어떻게 글자를 bit로 변환시키는지 (단순 연산, 비트 연산 등)와 signal이 무엇이고 전달되는 과정이 어떻게 되는지, 시그널을 보내고 대기를 하는 이유가 무엇인지, process가 무엇인지 (아주 가볍게) 정도만 공부하면 무난하게 통과할 수 있다.
